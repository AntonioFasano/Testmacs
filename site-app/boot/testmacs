## TODO
## Separate environments for assignment variables and management functions  
## Try source this from init with local(source(...)) and then add items in testamacs.var or testamacs.man env
## Everything not explicitely set in testmacs* env is disposed after sourcing
## Add test of local and remote write and stop with errors on fail

local({

    ## Compare values with site-start.el
    `exam-loc-server-ini`  <-     "~/server*.txt"
    `exam-net-init`        <-     "INITFILE*.txt"

    ## First working local init
    local.init <- Sys.glob(`exam-loc-server-ini`)[1]

    ## Remote data dir from local file
    data.dir <- Sys.glob(readLines (local.init)[1], dirmark=TRUE)

    ## First working remote init file 
    remote.init <- Sys.glob(paste0(data.dir, "INITFILE*.txt"))[1]

    ## Course name and data file
    remote.lines  <-  readLines(remote.init, 2)
    course.pos <- grep("course", strsplit(remote.lines[1], " +")[[1]], fixed=TRUE)
    course.name <-  strsplit(remote.lines[2], " +")[[1]][course.pos]
    course.data <- paste0(data.dir, "rdata/", course.name, "-nosol.RData")

    ## Set local and remote RDS paths
    rds.loc <- path.expand(paste0("~/", course.name, "-ans-", tolower(Sys.getenv("COMPUTERNAME")), ".rds"))
    rds.net  <- paste0(dirname(remote.init), "/",
                       course.name, "-answers/",
                       course.name, "-ans-", tolower(Sys.getenv("COMPUTERNAME")), ".rds")

    ## Load assignment
    load(course.data, envir=testmacs)

    ## Add course name to testmacs .assignment
    testmacs$.assignment$course.name  <-  course.name

    ## Add encoded remote rds testmacs .assignment
    testmacs$.assignment$rds.net  <-  charToRaw(rds.net)

    ## Read local answer text file 
    ansfile.loc <-  path.expand(paste0("~/", course.name, "-ans-", tolower(Sys.getenv("COMPUTERNAME")), ".txt"))

    ## Get student data
    ## Based on grade.R readAnswers, but without LaTeX sanitizing   
    lines <- readLines(ansfile.loc, warn=FALSE, encoding="UTF-8")
    stud <- sapply(regmatches(lines, regexec("(.+?):(.*)", lines)), function(l){
        x <- l[3]
        names(x) <- l[2]
        x})
    stud <- stud[!is.na(names(stud))] # for rate cases of fields with newlines    
    stud <- as.data.frame(stud, stringsAsFactors=FALSE, nm="Student")
    stud[,1] <- trimws(stud[,1])
    ## stud[,1] <- sanitize(stud[,1]) # see readAnswers()
    stud["ans-line",] <- gsub('"', '', stud["ans-line",]) # no quotes

    ## Add student data to testmacs .assignment
    testmacs$.assignment$student  <-  stud
    
    ## Make save list
    L <- list()
    L$values <- NULL
    L$.course.name <- .assignment$course.name 
    L$.student <- .assignment$student
    L$.rsavedat <-  Sys.time()

    ## Save local and remote dummy RDS
    if(file.exists(rds.loc)) file.remove(rds.loc)
    saveRDS(L, rds.loc)
    file.copy(rds.loc, rds.net)
        
})

send  <- function(...){

    ## Single arg without name
    if(is.null(names(list(...)))) stop("Please, provide argument names.")

    ## more args and some without name
    x <- which(!nzchar(names(list(...))))
    if(any(x)) stop("\nArgument(s) in position ", as.character(x),  " missing name(s).")

    ## Some value are functions
    x <- sapply(seq_along(list(...)), function(i) if(is.function(list(...)[[i]])) TRUE else FALSE)
    # Show first of which giving the problem
    if(any(x)) stop("\nThe value of ", names(list(...))[[which(x)[1] ]], " is a function not a value.")

    ## Make answer list
    A <- list(...)
    
    ## Make save list
    L <- list()
    L$values <- A
    L$.course.name <- .assignment$course.name 
    L$.student <- .assignment$student
    L$.rsavedat <-  Sys.time()
    ##L$.cmdhst <-  readLines(paste0("~/hst-", .assignment$course.name))

    ## Local save
    rds <- path.expand(paste0("~/", .assignment$course.name, "-ans-", tolower(Sys.getenv("COMPUTERNAME")), ".rds"))
    if(file.exists(rds)) file.remove(rds)
    saveRDS(L, rds)

    ## Remote save
    x <- rawToChar(.assignment$rds.net)
    if(file.exists(x)) file.remove(x)
    saveRDS(L, x)
    
    message("Data has been sent. Thank you.")
    readline("Hit any key to exit.")
    quit("no")
}

giveup  <- function(...){
    quit("no")
}

info <- function(){

    txt <- paste0("\n", .assignment$text, "\n")

    ## Add mandatory vars
    nms <- names(.assignment$classes)
    vals <- .assignment$classes
    cls <- sapply(seq_along(nms), function(i)  paste0("class(", nms[i], ")\t==\t\"", vals[i], "\""  ) )
    cls <- paste(cls, collapse="\n")
    txt <- rbind(txt, "\nClasses:\n", cls, "\n")

    
    ## Add optional vars
    nms <- names(.assignment$classes.opt)
    vals <- .assignment$classes.opt
    cls <- sapply(seq_along(nms), function(i)  paste0("class(", nms[i], ")\t==\t\"", vals[i], "\""  ) )
    cls <- paste(cls, collapse="\n")
    txt <- rbind(txt, "\nOptional variables:\n", cls, "\n")


    ## Add optional vars
    txt <- rbind(txt, "\nSee also info.send()", "\n")
 
    message(txt)
    
}

info.send <- function(){

    txt <- "\nTo send data use: \nsend(VARIABLE=VALUE, ...)\n"
    txt <- rbind(txt, "\nFor example, to send the variables 'a' and 'b' use:\n")
    txt <- rbind(txt, "send(a=a, b=b)\n")
    txt <- rbind(txt, "\nDo not forget to check classes before send.\n")
    message(txt)

}

