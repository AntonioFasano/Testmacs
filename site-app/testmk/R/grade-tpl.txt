## What
## "grade.R" reads "<course>-answers" + "<course>-quests" dirs and generates "<course>-results"
## Negative grades are set to 1 and missing exam-id's are set to NA

## How
## "<course>-answers" should be manually copied from Emacs server share to "mix.R" output dir;
## "<course>-quests" and "grade.R" and are generated by "mix.R" in its output dir

## EDIT WARNING
## "grade.R" is produced by "mix.R" using "grade-tpl.txt"
## Do not edit the template "grade-tpl.txt", but:
## 1. Run "grade.R" for testing
## 2. The file ../../grade.R.bak is produced
## 3 if you are satisfied with it, rename it "grade-tpl.txt"

## TODO
## Produce a PDF output for student with wrong or missing exam-id, explaining the result is NA

## Customise
SHOWGGRID <- FALSE  ## summary grid at PDF bottom


library(xtable)

main <- function(){

    ## Backup me in my grandparent
    backup.me()
    
    ## List ans dirs named as quest dirs
    ds <- sub("-answers$", "",  Sys.glob("*-answers"))
    ansdirs <- setNames(lapply(ds, function(d){
        q <- paste0(d, "-quests")
        a <- paste0(d, "-answers")
        ## There should be a quest dir for any ans dir
        if(!dir.exists(q)) stop("There is dir ", a, " but no dir ", q)
        setNames(a, q)}), ds)

    ## Course loop
    x <- lapply(ansdirs, function(ansd){

        ## Get course names
        course <- sub("-answers$", "",  ansd)
        
        ## Load "sols" list, "prequest", "flines" vectors
        ##   sols: per-exam list with student quests and sol grid
        ##   preamble, prequest, flines: LaTeX preamble/pre-question area/footer 
        load(paste0(names(ansd), "/", course, "-sols.RData"))

        message("\nProcessing ", course, ": ", length(sols))
        
        ## List answer files 
        afiles <- Sys.glob(paste0(ansd, "/", course, "-ans-*.txt"))        

        ## Get answers: for each seat a data frame in a list named by exam-id's
        A <- parseAnswers(afiles)

        ## Get student data
        contacts.str <- sapply(A, function(a)
            paste( a["given-name",], a["family-name",], a["student-id",], a["student-birth",],
                  "Seat:\\", a["seat-ex-file",], "Exam:\\", a["exam-id",]))

        ## ... as a matrix
        x <- c("given-name", "family-name", "student-id", "student-birth", "seat-ex-file", "exam-id")
        contacts <- t(sapply(A, function(a) a[x,]))
        contacts[, 1:3] <- toupper(contacts[, 1:3]) 
        colnames(contacts) <- x
        
        ## Extract exams IDs 
        examids <- sapply(A, `[`, "exam-id", )

        ## Consistency
        x <- which(examids=="nil")
        NOID <- ""
        if(length(x)>0) {
            NOID <- lapply(x, function(xi) paste("WARNING: Missing exam ID for", contacts.str[xi]))
            examids <- examids[-x]
        }

        x <- ! examids %in% names(sols)
        if(any(x)){
            x <- paste(examids[x], collapse=" ")
            stop(sprintf("Exam ID: %s not found. Are you really processing folder for course '%s?'",
                         x, course))
        }
        
        ## Calculate grades
        grades <- lapply(examids, function(examid){
            ans <- A[[examid]]
            sol <- sols[[examid]]$quests.sol
            grade(ans, sol)            
        })                

        ## Add student answer to questions (after the \question tag)
        gquests <- lapply(examids, function(examid){
            grade2quest(sols[[examid]]$quests, grades[[examid]])
        })
        
        ## Fill the header with score and contact details 
        hlines.id <- lapply(examids, function(examid){
            header.exam(prequest, contacts.str[examid], grades[[examid]] )})

        ## Fill the footer with score grid (only for SHOWGGRID true)
        flines.id <- lapply(examids, function(examid){
            sgrid2footer(flines, grades[[examid]])})

        
        ## Create result dir
        resdir <- paste0(course, "-results")
        createDir(resdir)

        ## Create result txt 
        x <- sapply(rownames(contacts), function(examid){paste(contacts.str[[examid]], grades[[examid]]$score)})
        fcon <- file(paste0(resdir, "/grades.txt"), encoding="UTF-8")
        writeLines(nolatex(x), fcon)
        close(fcon)
        
        ## Set missing exam-id grade to NA for CSV export
        x <- sapply(rownames(contacts), function(examid) ifelse(examid == "nil", NA, grades[[examid]]$score))

        ## Create result .csv
        contacts <- cbind(contacts, grade=x)
        write.csv(nolatex(contacts), paste0(resdir, "/grades.csv"),  row.names=FALSE)

        ## Create result PDFs
        lapply(examids, function(examid){
            message(which(examids==examid), " -> ", examid)

            footer=ifelse(SHOWGGRID, flines.id[[examid]], "\\end{questions}\n")

                    buildPdf(resdir, course, examid, gquests[[examid]],
                             preamble=preamble,                             
                             header=hlines.id[[examid]],
                             footer=footer,
                             libparent=names(ansd), combo=FALSE)
        })

        ## Build combo PDF
        buildPdf(resdir, course, examid,
                 gquest=NULL,                 
                 preamble=preamble,
                 header=preamble,
                                        #header=split.preamble(hlines)[[1]],
                 footer=NULL,
                 libparent=names(ansd), combo=TRUE)

        ## Inform of unusable tests
        message(paste(NOID, collapse="\n"))

    }) ## end Course loop
} ## ===== end main

sgrid2footer <- function(# Fill the header with score
                         flines,   # Course header lines
                         grades    # Student details 
                            ){

    flines <- sub("\\\\end\\{document\\}", "", flines)
    #flines <-
        paste(flines, print(xtable(grades$grid), floating=FALSE, print.results=FALSE))
    ## paste(flines, "\n\n\\end{document}\n")
}


header.exam <- function( # Replace first fbox with Exam specific header with contact details and score
                            hlines,  # Course header lines
                            contact, # Student details 
                            grades   # Student score
                            ){
    
    x <- getfbox(hlines)
    hlines <- x$hlines
    boxpos <- x$fbox

    ## Create fbox
    fbox <- "\\noindent\\fbox{\\parbox{0.49\\textwidth}{"
    ## Add contact data
    fbox <- c(fbox, paste(contact, "\n\n\\today"))
    ## Add score
    fbox <- c(fbox, sprintf("\\\\Your grade is: $%g$ (Good: %g, Wrong: %g)",
                              grades$score, grades$good, grades$bad))   
    fbox <- c(fbox, "}}")

    (hlines <- c(hlines[1:(boxpos-1)], fbox, hlines[(boxpos+1):length(hlines)]))
    
    #namer <- grep("^ *Full +name +and +signature:", hlines)
    #todayr <- grep("^ *Today +is +\\(",  hlines)
    #hlines[namer] <- paste(contact, "\\quad\\today")
    #hlines <- hlines[-((namer+1):todayr)]
    # 
    ### Add score
    #scorer <- grep("^ *Score", hlines)
    #hlines[scorer] <- sprintf("Score: $%g$ (Good: %g, Wrong: %g)",
    #                          grades$score, grades$good, grades$bad)
    #hlines
    
}

getfbox  <- function(hlines){
    ## Get begin/end of LaTeX \fbox in the quiz header,
    ## whose content is to be replaced with contact details and score

    match  <- regexpr("\\\\fbox *\\{", hlines)
    boxrow <- which(match>0)[1]
    if(is.na(boxrow)) stop("Missing \\fbox to be replaced with score and contact data.")
    boxchar.s <- match[boxrow]
    boxchar.e <- attr(match, "match.length")[boxrow]
    boxrow.bak <- hlines[boxrow]
    hlines[boxrow] <- substring(boxrow.bak,  boxchar.s + boxchar.e)

    end <- NA
    np <- 0
    n <- boxrow-1
    while(is.na(end)){
        n <- n + 1                
        pos <- gregexpr("\\{|\\}", hlines[n])
        m <- regmatches(hlines[n], pos)[[1]]
        m[m=="{"] <- -1
        m[m=="}"] <- 1
        m <- as.integer(m)
        end <- which(cumsum(m)+np ==1)[1]
        np <-  sum(np, m)
    }

    hlines <- c(hlines[1:boxrow], "", hlines[n:length(hlines)])        
    hlines[boxrow] <- substring(boxrow.bak, 0, boxchar.s -1)
    hlines[boxrow +2] <- substring(hlines[boxrow +2],  pos[[1]][end] +1)
    list(hlines=hlines, fbox=boxrow +1) 
}

grade2quest <- function( # Return questions with student answere after \question tag
                        quests,  # questions of n-th exam/student 
                        grades   # grades of n-th exam/student
                        ){
    
    lapply(seq_along(quests), function(i){
        q <- quests[[i]]             # i-th quest
        a <- grades$grid[["ans"]][i] # i-th ans
        a <- sprintf("\\textbf{(%s)}", toupper(a))
        q[1] <- paste(q[1], a)       # first quest
        q
    })        
}


createDir <- function(dirpath){ # Create output dir
    if(dir.exists(dirpath)) unlink(dirpath, recursive=TRUE)
    if(dir.exists(dirpath)) stop("Unable to delete directory ", dirpath)
    dir.create(dirpath)
    if(!dir.exists(dirpath)) stop("Unable to create directory ", dirpath)
}

plat <- function( # Path with proper slash for shell commands
                 pt){if(.Platform$OS.type=="windows") gsub("/", "\\\\", pt) else pt}

buildPdf <- function( # Build PDF with scores
                     resdir,         # result dir
                     coursename,     # 
                     examid,         # 
                     gquests,        # graded questions
                     preamble,       # LaTeX premable (inclding \begin{document})
                     header, footer, # LaTeX pre-quesitons header and footer
                     libparent,      # parent of local LaTeX libs directory
                     combo           # build combo? 
                     ){

    


    ## Combo file paths 
    fstem.c <- paste0(resdir, "/!", coursename, "-combo")
    ftex.c <- paste0(fstem.c, "-body.tex")
    ftex.c.con <- file(ftex.c, encoding="UTF-8", open="a") # append exams to body
    
    if(combo) {
        
        ## Build the combo
        footer <- "\n\n\\end{document}\n" 
        cat(footer, file=ftex.c.con, sep="\n", append=TRUE) # append footer to body
        ftex <- paste0(fstem.c, ".tex") # make final combo path
        ftex.con <- file(ftex, encoding="UTF-8") 
        writeLines(header, ftex.con) 
        file.append(ftex, ftex.c)
        
    } else {

        fstem <- paste0(resdir, "/", coursename, "-v", examid)    
        ftex <- paste0(fstem, ".tex")
        ftex.con <- file(ftex, encoding="UTF-8")        

        ## Save tex file with grades
        lines.body <- c(header, unlist(gquests))
        lines <- c(preamble, lines.body, footer, "\n\n\\end{document}\n")        
        writeLines(lines, ftex.con)

        ## Append to combo tex file        
        footer <- "\n\n\\end{questions}\n\\newpage\\cleardoublepage" # next test will start on a new odd page 
        cat(c(lines.body, footer), file=ftex.c.con, sep="\n", append=TRUE)
        
    }

    ## Clean
    close(ftex.c.con)
    close(ftex.con)

    
    ## Build PDF
    libs <- env <- character()
    if(.Platform$OS.type=="windows") libs <- paste0("--include-directory=", plat(libparent))
    if(.Platform$OS.type=="unix") env  <- paste0("TEXINPUTS=", plat(libparent), ":") 

    #libs <- paste0("--include-directory=", plat(libparent))
    nout <- plat(dirname(ftex))
    ntex <- plat(ftex)
    ags =paste0(libs, " -halt-on-error -output-directory=", nout, " ", ntex)
    ret=system2("pdflatex", ags, stdout=TRUE, stderr=TRUE, env=env, timeout=15)  
    if(!is.null(attr(ret, "status"))) stop("pdflatex gave: ", paste(ret, collapse="\n"))
    ## Second build
    ret=system2("pdflatex", ags, stdout=TRUE, stderr=TRUE, env=env, timeout=15)  
    if(!is.null(attr(ret, "status"))) stop("pdflatex gave: ", paste(ret, collapse="\n"))

    ## Clean up
    if(combo) {
        ff <- Sys.glob(paste0(fstem.c, "*"))
        x <- grep("\\.pdf$", ff)
        unlink(ff[-x])
    } else {
        ff <- Sys.glob(paste0(fstem, ".*"))
        x <- grep("\\.pdf$", ff)
        unlink(ff[-x])
    }
}


parseAnswers <- function(## Parse answer files as a list whose names are exam IDS
                         ## Each seat element is data frame with fields by row
                         afiles # answer file paths (containing seats)
                         ){
    
    ## Read answers and 
    adata <- lapply(afiles, readAnswers)

    ## Add seat from file name (there can be also a field seat)
    seats <- tools:::file_path_sans_ext(basename(afiles))
    seats <- sub("^.+-ans-", "", seats)
    adata <- mapply(function(stud, seat){
        rbind(data.frame(Student=seat, row.names="seat-ex-file", stringsAsFactors=FALSE), stud)},
        adata, seats, SIMPLIFY=FALSE)

    ## Name answers after exam IDs
    examids <- sapply(adata, `[`, "exam-id", )
    setNames(adata, examids)
}
  

readAnswers <- function(af){ # Read and preformat answer files 

    lines <- readLines(af, warn=FALSE, encoding="UTF-8")
    stud <- sapply(regmatches(lines, regexec("(.+?):(.*)", lines)),
                   function(l) setNames(l[3],l[2]))

    ## If one adds a new line in a field, we take only the first field line
    ## Adding \n is rare (eg with a C-y yank)
    stud <- stud[!is.na(names(stud))]
    
    stud <- as.data.frame(stud, stringsAsFactors=FALSE, nm="Student")

    ## Trim spaces and sanitize
    stud[,1] <- trimws(stud[,1])
    stud[,1] <- sanitize(stud[,1])
    stud["ans-string",] <- gsub('"', '', stud["ans-string",]) # no quotes
    stud    
}


parseAnswers.old <- function(## parse answer files as a list whose names are seats,
                         ## each seat element is data frame with fields by row
                         afiles, # answer file paths (containing seats)
                         adata   # list where each elt is the file contents
                         ){
    
    ## Extract seats from path
    seats=tools:::file_path_sans_ext(basename(afiles))
    seats=sub("^.+-ans-", "", seats)

    ## For each answer set fields as DF rows 
    adata=lapply(adata, function(a) {
            x=a[,2, drop=FALSE]
            row.names(x) =a[[1]]
            names(x)="Student"
            x[,1]=trimws(x[,1])
            x[,1] <- sanitize(x[,1])
            x["ans-string",] <- gsub('"', '', x["ans-string",])
            x})

    ## Add seat field to DF rows 
    adata <- lapply(seq_along(seats), function(i) {
        x <- rbind(seats[i],adata[[i]])
        row.names(x)[1] <-  "seat"
        x
    })

    ## Name DF in the list by exam ID
    examids <- sapply(adata, `[`, "exam-id", )
    setNames(adata, examids)    
}
                         
grade <- function( # Grade the answer vector
                  ans, # i-th answers
                  sol  # i-th solution sub-list
                  ){

    ## get related sols ans weights 
    s=sol$sol
    w=sol$weight

    ## Get answer letters
    al=ans["ans-string",]
    al=strsplit(al, " ")[[1]]

    ## Vector by type of answers

    # was
    #good <- as.integer(s==al)    # 1 if good: sum(good)
    #nil <- as.integer("nil"!=al) # 0 if nil:  sum(-nil+1)
    #bad  <- as.integer(s!=al)    # 1 if non-good: nil %*% bad or sum(bad) - sum(-nil+1)
    #L <- list(score=c(good %*% w - nil %*% bad), good=sum(good), bad=nil %*% bad,
    #     grid=data.frame(ans=al, sol=s, weight=w, stringsAsFactors=FALSE))

    good <- as.integer(s==al)        # 1 each good, 0 else
    nil <- as.integer("nil"==al)     # 1 each nil,  0 else
    ## non-good and non-nil are bad
    bad <- as.integer(!good & !nil)  # 1 each bad,  0 else
    
    list(score=c(good %*% w - sum(bad)), good=sum(good), bad=sum(bad), 
            grid=data.frame(ans=al, sol=s, weight=w, stringsAsFactors=FALSE))

}

sanitize <-  function(s){ # LaTeX safe chars
    first <- "]["
    legal <- "!@*()+-=;',./`:?\" "
    pat <- paste0(first, "[:alnum:]", legal)
    pat <- paste0("[^", pat, "]")
    s <- gsub(pat, "", s)
    gsub("@", "$@$", s)        
}

nolatex <-  function(s){ # Currently fixes "$@$" as simple "@" and \-space
### Works also if s is a character matrix
    
    s <- gsub("\\$@\\$", "@", s)
    gsub("\\\\ ", " ", s)
    
}
    
backup.me <- function()
    ## During testing it is convenent to modify "grade.R" rather than its template;
    ## but mix.R might overwrite "grade.R" parent, so a backup is made in the grandparent
    file.copy("grade.R", "./../grade.R.bak", overwrite=TRUE) 

## not used
split.preamble <- function(lines){
    ## Given lines char vector, return a list, where
    ## the first element is the preamble + begin{document}
    ## the second element is the remaining lines
    ## Assumes \begin{document} is assumed on a single line

    x=grep("^\\s*\\\\begin\\s*\\{document\\}", lines)
    preamble <- lines[1:x]
    lines <- lines[-(1:x)] # after begin document
    list(preamble, lines)
}


debanswers <- function() { # Add to answer files good examd IDs taken from "course-sols.RData"
    
    ## Get course names
    courses <- sub("-answers$", "",  Sys.glob("*-answers"))    

    x <- lapply(courses, function(course) {

        message(course)

        ## Read exam IDs from solution file
        qdir <- paste0(course, "-quests")
        load(paste0(qdir, "/", course, "-sols.RData"))

        ## Make exam id string from solution 
        goodexamids  <- paste("exam-id:", names(sols))

        ## Read file content 
        adir <- paste0(course, "-answers")
        afiles <- Sys.glob(paste0(adir, "/", course, "-ans-*.txt"))
        answers <- lapply(afiles, readLines, warn=FALSE, encoding="UTF-8")

        ## Test available solutions
        file.count <- length(answers)
        if(file.count > length(goodexamids)) stop("More files than solutions for debugging")   
        
        message("Before:")
        print(sapply(answers, `[[`, 1))

        
        ## Assign from solution and show
        answers <- lapply(1:file.count, function(i) {
            answers[[i]][1]  <- goodexamids[i]
            answers[[i]]
        })
          
        message("After:")
        print(sapply(answers, `[[`, 1))

        ## Rewrite answers to files
        sapply(seq_along(answers), function(i) writeLines(answers[[i]], afiles[i]))

    })
            
}

    
